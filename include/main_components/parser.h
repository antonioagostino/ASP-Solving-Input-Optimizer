#ifndef PARSER_H
#define PARSER_H
#include <vector>
#include <list>
#include <string>
#include <sstream>
#include <unordered_map>
#include "aspif_minimize_statement.h"
#include "aspif_rule_statement.h"
namespace aspsio {

    // A generalization of a Parser, it works as interface for 
    // all types of parser
    
    class Parser {
        protected:
            std::vector<std::string> *input_encoding;

            // Each list of rules contains only rules rewritten by 
            // the SAME Rewriting method (a rule can exist in two or more lists)
            std::vector<std::list<Rule*>> *rules_to_optimize;

            //Patterns of the fresh predicates generated by a Rewriting 
            std::vector<std::string> *patterns_to_match;

            // The first element is the predicate's id
            // The second element is the type of Rewriting
            std::vector<std::pair<int, int>> aux_predicates;

            // An Hash Table of auxiliar predicates used to save their
            // occurrences in rules
            std::unordered_map<int, Predicate*> aux_predicates_instances;

            int line_to_parse;

        public:
            Parser(std::vector<std::string> &input_data, std::vector<std::list<Rule*>> &rules_sets, 
                    std::vector<std::string> &pattern_set);
            virtual void StartAnalysis() = 0;
            void AddReverseParsingOption(const std::string &pattern);
            std::unordered_map<int, Predicate*>& GetAuxPredicatesInstances(){
                return aux_predicates_instances;
            }
    };
}

#endif